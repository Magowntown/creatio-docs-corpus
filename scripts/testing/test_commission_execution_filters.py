#!/usr/bin/env python3
"""Test Commission filtering using the PROD-style flow.

Why
- In PROD compiled schema, Commission export is generated by:
  1) inserting BGReportExecution (stores BGYearMonth + BGSalesGroup)
  2) running IntExcelExport with an ESQ filtered by BGExecutionId = that execution id
  3) calling IntExcelReportService/GetExportFiltersKey to obtain ExportFilterKey_...
  4) downloading via IntExcelReportService/GetExportFilteredData/{fileName}/{key}

DEV differs
- DEV uses the custom service UsrExcelReportService/Generate and downloads via
  IntExcelReportService/GetReport/{key}/{reportNameSegment}.

Credentials
- Reads .env blocks (supports both commented and uncommented PROD blocks)

Safety
- Never prints secrets.
- In PROD, creates then deletes BGReportExecution rows for each test.

Usage
  python3 scripts/testing/test_commission_execution_filters.py --env prod --count 3
  python3 scripts/testing/test_commission_execution_filters.py --env dev --count 3

Diagnostics
  # If the Excel 'Year-Month' column is empty/missing, allow deriving YYYY-MM from dates
  # (not recommended for PROD semantics; use only to debug odd files)
  python3 scripts/testing/test_commission_execution_filters.py --env prod --count 3 --allow-derived-yearmonth
"""

from __future__ import annotations

import argparse
import json
import re
import sys
import time
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple
from urllib.parse import quote

REPO_ROOT = Path(__file__).resolve().parents[2]
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

from scripts.testing.test_commission_dynamic_filters import (
    Creatio,
    Combo,
    _parse_env_with_commented_blocks,
    _sanitize_filename,
    _xlsx_extract_unique_values,
)

ENV_PATH = REPO_ROOT / ".env"


def _resolve_int_excel_report(creatio: Creatio, int_name: str) -> Dict[str, Any]:
    body = {
        "rootSchemaName": "IntExcelReport",
        "operationType": 0,
        "columns": {
            "items": {
                "Id": {"expression": {"columnPath": "Id"}},
                "IntName": {"expression": {"columnPath": "IntName"}},
                "IntEsq": {"expression": {"columnPath": "IntEsq"}},
            }
        },
        "filters": {
            "filterType": 6,
            "items": {
                "IntNameFilter": {
                    "filterType": 1,
                    "comparisonType": 3,
                    "leftExpression": {"expressionType": 0, "columnPath": "IntName"},
                    "rightExpression": {
                        "expressionType": 2,
                        "parameter": {"dataValueType": 1, "value": int_name},
                    },
                }
            },
        },
        "rowCount": 1,
    }
    data = creatio.select_query(body)
    rows = data.get("rows") or []
    if not rows:
        raise RuntimeError(f"IntExcelReport not found for IntName={int_name!r}")
    return rows[0]


def _load_year_month_name_to_id(creatio: Creatio, limit: int = 500) -> Dict[str, str]:
    body = {
        "rootSchemaName": "BGYearMonth",
        "operationType": 0,
        "columns": {
            "items": {
                "Id": {"expression": {"columnPath": "Id"}},
                "Name": {"expression": {"columnPath": "Name"}},
            }
        },
        "rowCount": limit,
    }
    data = creatio.select_query(body)
    rows = data.get("rows") or []
    out: Dict[str, str] = {}
    for r in rows:
        ym_id = r.get("Id")
        name = r.get("Name")
        if isinstance(ym_id, str) and isinstance(name, str) and re.fullmatch(r"\d{4}-\d{2}", name.strip()):
            out[name.strip()] = ym_id
    return out


def _discover_combos_from_salesgroup_by_yearmonth(
    creatio: Creatio,
    *,
    year_month_name_to_id: Dict[str, str],
    max_candidates: int = 200,
) -> List[Combo]:
    """Use BGCommissionSalesGroupByYearMonth (SQL-view-backed) as the source of truth for combos."""

    body = {
        "rootSchemaName": "BGCommissionSalesGroupByYearMonth",
        "operationType": 0,
        "columns": {
            "items": {
                "BGYearMonthName": {"expression": {"columnPath": "BGYearMonth.Name"}},
                "BGSalesGroup": {"expression": {"columnPath": "BGSalesGroup"}},
                "BGSalesGroupName": {"expression": {"columnPath": "BGSalesGroup.BGSalesGroupName"}},
            }
        },
        "rowCount": 5000,
    }
    data = creatio.select_query(body)
    rows = data.get("rows") or []

    combos: List[Combo] = []
    seen: set[Tuple[str, str]] = set()

    for r in rows:
        ym_name = r.get("BGYearMonthName")
        if not (isinstance(ym_name, str) and re.fullmatch(r"\d{4}-\d{2}", ym_name.strip())):
            continue
        ym_name = ym_name.strip()
        ym_id = year_month_name_to_id.get(ym_name)
        if not ym_id:
            continue

        sg_lookup = r.get("BGSalesGroup")
        sg_id = None
        if isinstance(sg_lookup, dict):
            v = sg_lookup.get("value")
            if isinstance(v, str):
                sg_id = v
        if not sg_id:
            continue
        sg_name = r.get("BGSalesGroupName")
        if not isinstance(sg_name, str) or not sg_name.strip():
            sg_name = "(unknown)"
        sg_name = sg_name.strip()

        key = (ym_id, sg_id)
        if key in seen:
            continue
        seen.add(key)
        combos.append(
            Combo(
                year_month_id=ym_id,
                year_month_name=ym_name,
                sales_group_id=sg_id,
                sales_group_name=sg_name,
            )
        )
        if len(combos) >= max_candidates:
            break

    # Prefer newest months first.
    combos.sort(key=lambda c: c.year_month_name, reverse=True)
    return combos


def _build_commission_esq_template() -> Dict[str, Any]:
    """Minimal ESQ that matches the PROD Commission case (column paths + captions)."""

    def col(caption: str, column_path: str) -> Dict[str, Any]:
        return {
            "caption": caption,
            "orderDirection": 0,
            "orderPosition": -1,
            "isVisible": True,
            "expression": {"expressionType": 0, "columnPath": column_path},
        }

    return {
        "rootSchemaName": "BGCommissionReportDataView",
        "operationType": 0,
        "includeProcessExecutionData": True,
        "columns": {
            "items": {
                "Sales Rep": col("Sales Rep", "BGSalesRep"),
                "Sales Group": col("Sales Group", "BGSalesRep.BGSalesGroupLookup"),
                "Customer": col("Customer", "BGOrder.Account"),
                "PO Number": col("PO Number", "BGPONumber"),
                "Invoice Date": col("Invoice Date", "BGOrder.BGInvoiceDate"),
                "Amount": col("Amount", "BGAmount"),
                "Commission": col("Commission", "BGCommission"),
                "Commission Rate Percentage": col("Commission Rate Percentage", "BGCommissionRatePercentage"),
                "Transaction Date": col("Transaction Date", "BGTransactionDate"),
                "Transaction Type": col("Transaction Type", "BGTransactionType"),
                "Is Note": col("Is Note", "BGIsNote"),
                "Description": col("Description", "BGDescription"),
                "Year-Month": col("Year-Month", "BGYearMonth.Name"),
            }
        },
        "isDistinct": False,
        "rowCount": -1,
        "rowsOffset": -1,
        "isPageable": False,
        "allColumns": False,
        "useLocalization": True,
        "useRecordDeactivation": False,
        "serverESQCacheParameters": {"cacheLevel": 0, "cacheGroup": "", "cacheItemName": ""},
        "queryOptimize": False,
        "useMetrics": False,
        "adminUnitRoleSources": 0,
        "querySource": 0,
        "ignoreDisplayValues": False,
        "isHierarchical": False,
    }


def _build_esq_with_execution_filter(int_esq_raw: str, execution_id: str) -> str:
    """Build an ESQ string that filters by BGExecutionId = execution_id.

    PROD note: some environments have IntExcelReport.IntEsq empty for Commission,
    so we fall back to a minimal template that matches the PROD UI case.
    """

    if not int_esq_raw:
        esq = _build_commission_esq_template()
    else:
        try:
            esq = json.loads(int_esq_raw)
        except Exception:
            esq = {}
        if not isinstance(esq, dict):
            esq = {}

    esq.setdefault("rootSchemaName", "BGCommissionReportDataView")
    esq.setdefault("operationType", 0)

    esq["filters"] = {
        "filterType": 6,
        "items": {
            "ExecutionFilter": {
                "filterType": 1,
                "comparisonType": 3,
                "isEnabled": True,
                "trimDateTimeParameterToDate": False,
                "leftExpression": {"expressionType": 0, "columnPath": "BGExecutionId"},
                "rightExpression": {
                    "expressionType": 2,
                    "parameter": {"dataValueType": 0, "value": execution_id},
                },
            }
        },
        "logicalOperation": 0,
        "isEnabled": True,
    }

    return json.dumps(esq)


def _insert_bg_report_execution(
    creatio: Creatio,
    *,
    year_month_id: str,
    sales_group_id: str,
    report_name: str = "Commission",
) -> str:
    url = f"{creatio.base_url}/0/DataService/json/SyncReply/InsertQuery"
    body = {
        "rootSchemaName": "BGReportExecution",
        "operationType": 1,
        "columnValues": {
            "items": {
                "BGReportName": {"expressionType": 2, "parameter": {"dataValueType": 1, "value": report_name}},
                "BGYearMonth": {"expressionType": 2, "parameter": {"dataValueType": 0, "value": year_month_id}},
                "BGSalesGroup": {"expressionType": 2, "parameter": {"dataValueType": 0, "value": sales_group_id}},
            }
        },
    }
    resp = creatio.session.post(url, json=body, headers=creatio.headers(), timeout=60)
    if resp.status_code != 200:
        raise RuntimeError(f"InsertQuery BGReportExecution failed: HTTP {resp.status_code} {resp.text[:200]}")
    data = resp.json()
    execution_id = data.get("id") or data.get("Id")
    if not isinstance(execution_id, str) or not execution_id:
        raise RuntimeError(f"InsertQuery did not return id: keys={list(data.keys())}")
    return execution_id


def _delete_bg_report_execution(creatio: Creatio, execution_id: str) -> None:
    url = f"{creatio.base_url}/0/DataService/json/SyncReply/DeleteQuery"
    body = {
        "rootSchemaName": "BGReportExecution",
        "operationType": 2,
        "filters": {
            "filterType": 6,
            "items": {
                "id": {
                    "filterType": 1,
                    "comparisonType": 3,
                    "isEnabled": True,
                    "trimDateTimeParameterToDate": False,
                    "leftExpression": {"expressionType": 0, "columnPath": "Id"},
                    "rightExpression": {
                        "expressionType": 2,
                        "parameter": {"dataValueType": 0, "value": execution_id},
                    },
                }
            },
            "logicalOperation": 0,
            "isEnabled": True,
        },
    }
    resp = creatio.session.post(url, json=body, headers=creatio.headers(), timeout=60)
    if resp.status_code != 200:
        raise RuntimeError(f"DeleteQuery BGReportExecution failed: HTTP {resp.status_code} {resp.text[:200]}")


EMPTY_GUID = "00000000-0000-0000-0000-000000000000"


def _prod_get_export_filters_key(creatio: Creatio, report_id: str, esq_string: str) -> str:
    """PROD flow: IntExcelReportService/GetExportFiltersKey => ExportFilterKey_..."""
    url = f"{creatio.base_url}/0/rest/IntExcelReportService/GetExportFiltersKey"
    body = {
        "EsqString": esq_string,
        "ReportId": report_id,
        "RecordCollection": [],
    }
    resp = creatio.session.post(url, json=body, headers=creatio.headers(), timeout=max(creatio.timeout_s, 300))
    if resp.status_code != 200:
        raise RuntimeError(f"IntExcelReportService/GetExportFiltersKey failed: HTTP {resp.status_code} {resp.text[:200]}")
    data = resp.json()
    key = data.get("key") or data.get("Key")
    if not (data.get("success") and isinstance(key, str) and key):
        raise RuntimeError(f"GetExportFiltersKey returned success={data.get('success')} keys={list(data.keys())}")
    return key


def _prod_download_export_filtered_data(creatio: Creatio, file_name: str, key: str) -> bytes:
    """PROD flow: IntExcelReportService/GetExportFilteredData/{fileName}/{key} => xlsx"""
    safe_file_name = quote(file_name, safe="")
    safe_key = quote(key, safe="")
    url = f"{creatio.base_url}/0/rest/IntExcelReportService/GetExportFilteredData/{safe_file_name}/{safe_key}"
    resp = creatio.session.get(url, headers=creatio.headers(), timeout=max(creatio.timeout_s, 300))
    if resp.status_code != 200:
        raise RuntimeError(f"GetExportFilteredData failed: HTTP {resp.status_code} {resp.text[:200]}")
    content = resp.content
    if content[:2] != b"PK":
        raise RuntimeError(f"GetExportFilteredData did not return xlsx/xlsm (signature={content[:8]!r})")
    return content


def _dev_generate_usr_excel_report(creatio: Creatio, report_id: str, *, year_month_id: str, sales_group_id: str) -> str:
    """DEV flow: UsrExcelReportService/Generate => ExportFilterKey_..."""
    url = f"{creatio.base_url}/0/rest/UsrExcelReportService/Generate"
    body = {
        "ReportId": report_id,
        "YearMonthId": year_month_id or EMPTY_GUID,
        # legacy field name; carries a SalesGroupId
        "SalesRepId": sales_group_id or EMPTY_GUID,
        "ExecutionId": EMPTY_GUID,
        "RecordCollection": [],
    }
    resp = creatio.session.post(url, json=body, headers=creatio.headers(), timeout=max(creatio.timeout_s, 300))
    if resp.status_code != 200:
        raise RuntimeError(f"UsrExcelReportService/Generate failed: HTTP {resp.status_code} {resp.text[:200]}")
    data = resp.json()
    key = data.get("key") or data.get("Key")
    if not (data.get("success") and isinstance(key, str) and key):
        raise RuntimeError(f"Generate returned success={data.get('success')} keys={list(data.keys())}")
    return key


def _dev_download_get_report(creatio: Creatio, key: str, report_name_segment: str = "Commission") -> bytes:
    url = f"{creatio.base_url}/0/rest/IntExcelReportService/GetReport/{quote(key, safe='')}/{quote(report_name_segment, safe='')}"
    resp = creatio.session.get(url, headers=creatio.headers(), timeout=max(creatio.timeout_s, 300))
    if resp.status_code != 200:
        raise RuntimeError(f"IntExcelReportService/GetReport failed: HTTP {resp.status_code} {resp.text[:200]}")
    content = resp.content
    if content[:2] != b"PK":
        raise RuntimeError(f"GetReport did not return xlsx/xlsm (signature={content[:8]!r})")
    return content


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--env", choices=["dev", "prod"], required=True)
    ap.add_argument("--count", type=int, default=3)
    ap.add_argument("--int-name", default="Rpt Commission")
    ap.add_argument("--timeout-seconds", type=int, default=180)
    ap.add_argument("--sleep-between", type=float, default=0.5)
    ap.add_argument("--report-name-segment", default="Commission")
    ap.add_argument(
        "--allow-derived-yearmonth",
        action="store_true",
        help=(
            "If the Excel 'Year-Month' column is empty, allow deriving YYYY-MM from dates. "
            "Not recommended for PROD semantics; intended for diagnostic use only."
        ),
    )
    args = ap.parse_args()

    blocks = _parse_env_with_commented_blocks(ENV_PATH)
    cfg = blocks.get(args.env) or {}

    base_url = (cfg.get("CREATIO_URL") or "").rstrip("/")
    username = cfg.get("CREATIO_USERNAME") or ""
    password = cfg.get("CREATIO_PASSWORD") or ""
    if not base_url or not username or not password:
        raise RuntimeError(f"Missing CREATIO_URL/CREATIO_USERNAME/CREATIO_PASSWORD for env={args.env}")

    out_dir = REPO_ROOT / "test-artifacts" / "execution-filters" / args.env
    out_dir.mkdir(parents=True, exist_ok=True)

    creatio = Creatio(base_url, username, password, timeout_s=args.timeout_seconds)
    creatio.login()

    report = _resolve_int_excel_report(creatio, args.int_name)
    report_id = report.get("Id")
    int_esq = report.get("IntEsq")
    if not isinstance(report_id, str) or not report_id:
        raise RuntimeError("Failed to resolve report Id")
    # In some environments (notably PROD), IntEsq can be an empty string for Commission.
    if not isinstance(int_esq, str):
        int_esq = ""

    report_name_segment = (args.report_name_segment or "Commission").strip() or "Commission"

    ym_map = _load_year_month_name_to_id(creatio)
    candidates = _discover_combos_from_salesgroup_by_yearmonth(creatio, year_month_name_to_id=ym_map)
    if not candidates:
        raise RuntimeError("No combos found in BGCommissionSalesGroupByYearMonth")

    results: List[Dict[str, Any]] = []
    successes: List[Dict[str, Any]] = []

    attempts = 0
    for combo in candidates:
        if len(successes) >= args.count:
            break

        attempts += 1
        started = time.time()
        execution_id: Optional[str] = None
        try:
            if args.env == "prod":
                execution_id = _insert_bg_report_execution(
                    creatio,
                    year_month_id=combo.year_month_id,
                    sales_group_id=combo.sales_group_id,
                )

                esq_string = _build_esq_with_execution_filter(int_esq, execution_id)
                key = _prod_get_export_filters_key(creatio, report_id, esq_string)
                content = _prod_download_export_filtered_data(creatio, report_name_segment, key)
            else:
                # DEV uses the deployed custom service (no BGReportExecution required).
                key = _dev_generate_usr_excel_report(
                    creatio,
                    report_id,
                    year_month_id=combo.year_month_id,
                    sales_group_id=combo.sales_group_id,
                )
                content = _dev_download_get_report(creatio, key, report_name_segment)

            inspection = _xlsx_extract_unique_values(
                content,
                year_month_expected=combo.year_month_name,
                sales_group_expected=combo.sales_group_name,
                allow_derived_yearmonth=bool(args.allow_derived_yearmonth),
            )

            elapsed = round(time.time() - started, 2)
            safe_name = _sanitize_filename(combo.sales_group_name)
            filename = out_dir / f"Commission_exec_{combo.year_month_name}_{safe_name}_{key[-8:]}.xlsx"
            filename.write_bytes(content)

            ok = bool(inspection.get("ok"))
            reason = (inspection.get("reason") if isinstance(inspection, dict) else None) or None
            status = "pass" if ok else ("inconclusive" if reason == "missing-year-month-values" else "fail")

            row = {
                "status": status,
                "ok": ok,
                "year_month": combo.year_month_name,
                "year_month_id": combo.year_month_id,
                "sales_group": combo.sales_group_name,
                "sales_group_id": combo.sales_group_id,
                "execution_id": execution_id,
                "key": key,
                "file": str(filename),
                "file_size": filename.stat().st_size,
                "inspection": inspection,
                "elapsed_s": elapsed,
            }
            results.append(row)
            if status == "pass":
                successes.append(row)
        except Exception as e:
            elapsed = round(time.time() - started, 2)
            results.append(
                {
                    "status": "fail",
                    "ok": False,
                    "year_month": combo.year_month_name,
                    "year_month_id": combo.year_month_id,
                    "sales_group": combo.sales_group_name,
                    "sales_group_id": combo.sales_group_id,
                    "execution_id": execution_id,
                    "error": str(e)[:600],
                    "elapsed_s": elapsed,
                }
            )
        finally:
            if execution_id:
                try:
                    _delete_bg_report_execution(creatio, execution_id)
                except Exception:
                    # best-effort cleanup
                    pass
            if args.sleep_between:
                time.sleep(args.sleep_between)

    summary = {
        "env": args.env,
        "ts": time.time(),
        "target": base_url,
        "requested_successes": args.count,
        "year_month_validation": "allow-derived" if args.allow_derived_yearmonth else "strict",
        "successes": successes,
        "attempts": attempts,
        "results": results,
    }
    (out_dir / "summary.json").write_text(json.dumps(summary, indent=2), encoding="utf-8")

    by_status = {"pass": 0, "fail": 0, "inconclusive": 0}
    for r in results:
        st = r.get("status")
        if st in by_status:
            by_status[st] += 1

    print(
        f"Found {len(successes)}/{args.count} passing combinations in {attempts} attempt(s) (execution-id flow; ym_validation={'allow-derived' if args.allow_derived_yearmonth else 'strict'})"
    )
    print(f"Attempt outcomes: pass={by_status['pass']} fail={by_status['fail']} inconclusive={by_status['inconclusive']}")

    for i, s in enumerate(successes, start=1):
        insp = s.get("inspection") or {}
        src = insp.get("derived_year_month_source")
        print(
            f"{i}. {s['year_month']} | {s['sales_group']} | rows(scanned)={insp.get('nonempty_data_rows_scanned')} | ym_src={src} | size={s['file_size']}"
        )

    return 0 if len(successes) >= args.count else 2


if __name__ == "__main__":
    raise SystemExit(main())
