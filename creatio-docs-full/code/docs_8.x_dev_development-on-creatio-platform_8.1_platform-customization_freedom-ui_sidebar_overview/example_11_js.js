/* Import the required functionality from the libraries. */import { BaseRequest, BaseRequestHandler, CrtRequestHandler, HttpClientService } from "@creatio-devkit/common";import { SOME_SIDEBAR_CODE } from "./constants";import { SomeService } from "./services/some-service.service";interface GetUnreadMessagesResponse {  messages: string[];}@CrtRequestHandler({  type: 'usr.SomeSidebarInitHandler',  requestType: 'crt.SidebarInitRequest',})export class InitializeSomeSidebarHandler extends BaseRequestHandler {  constructor(    /* Create an instance of the HTTP client from the "@creatio-devkit/common" library. */    private readonly _httpClient: HttpClientService,    /* Create an instance of the "SomeService." */    private readonly _someService: SomeService  )  {    super();  }  /* Display a notification mark on the sidebar icon when the web service sends required data. */  private async _showNotificationMark(): Promise<void> {    await this.handlerChain.process({      type: 'crt.ShowSidebarNotificationMarkRequest',      sidebarCode: SOME_SIDEBAR_CODE,      $context: {}    } as BaseRequest);  }  /* Open the sidebar when the web service sends required data.*/  private async _openSidebar(): Promise<void> {    await this.handlerChain.process({      type: 'crt.OpenSidebarRequest',      sidebarCode: SOME_SIDEBAR_CODE,      $context: {}    } as BaseRequest);  }  /* Wait for data sent by the web service. When Creatio receives data, display a notification mark on the sidebar icon. */  private async _checkUnreadMessages(): Promise<void> {    /* Specify the URL to retrieve the list of unread messages. Use the "EventService" web service. */    const endpointUrl = `rest/EventService/GetUnreadMessages`;    /* Add some description here. */    const result = await this._httpClient.post<GetUnreadMessagesResponse>(endpointUrl, null, {      responseType: 'json',    });    /* Check whether a unread message occurs. If it happens, display a notification mark on the sidebar icon. */    if (result.body && result.body.messages.length > 0) {      await this._showNotificationMark();    }  }  /* Return the sidebar state. */  private async _getSidebarState(): Promise<{ available: boolean, opened: boolean }> {    return (await this.handlerChain.process({      type: 'crt.GetSidebarStateRequest',      sidebarCode: SOME_SIDEBAR_CODE,      $context: {}    } as BaseRequest)) as { available: boolean, opened: boolean };  }  /* Check whether the sidebar is available. */  private async _isSidebarAvailable(): Promise<boolean> {    const sidebarState = await this._getSidebarState();    return sidebarState.available;  }  /* Check whether the sidebar is open. */  private async _isSidebarOpened(): Promise<boolean> {    const sidebarState = await this._getSidebarState();    return sidebarState.opened;  }  /* Refresh sidebar data when it is opened. */  private async _refreshSidebarData(): Promise<void> {    await this.handlerChain.process({      type: 'usr.RefreshSomeSidebarDataRequest',      $context: {}    });  }  /* Handle the data sent by the web service. */  private async _handleWebServiceEvent(): Promise<void> {    /* Check whether the sidebar is open. */    if (await this._isSidebarOpened()) {      /* Refresh sidebar data. */      await this._refreshSidebarData();    } else {      /* Open the sidebar when the web service sends required data. */      await this._openSidebar();    }  }  /* Subscribe to the data sent by the web service. When Creatio receives data, handle it. */  private async _subscribeToWebServiceEvents(): Promise<void> {    this._someService.getEventsObservable().then(() => {      /* Handle the received data. */      this._handleWebServiceEvent().then();    });  }  public async handle(request: BaseRequest): Promise<void> {    /* Check whether the sidebar is available. */    if (await this._isSidebarAvailable()) {      /* Wait for data sent by the web service. */      this._checkUnreadMessages().then();      /* Subscribe to the data sent by the web service. */      this._subscribeToWebServiceEvents();    }    /* Call the next handler if it exists and return its result. */    await this.next?.handle(request);  }}